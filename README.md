# ZK Bug Bounty

## Motivation

In the last few years more than a billion dollars were stolen from smart contracts (here are list of the biggest hacks: [Rekt News](https://rekt.news/leaderboard/)). Classic bug bounty solutions, like [Immunefi](https://immunefi.com), financially incentivize hackers to report a vulnerability. Payment for exposing the vulnerability however is not guaranteed; the severity of the bug is at the discretion of the project posting the bug bounty, who could claim the exploit as "not a real vulnerability". In short, a rational hacker is incentivized to exploit the vulnerability instead of report it.

We propose to write a system, where a hacker can **formally** and **mathematically** prove the bug.

## Architecture

### State Transition Proof

All the business logic of user function (for example function `transfer` in some pseudoERC20 Token) will be implemented as ZK circuit. For example, if user Alice wants to send money to Bob - Alice will generate zk proof, which will change the state from `state0` to `state1`, let's call this proof a `State Transition Proof`

### Hack Proof

Imagine a hacker finds a vulnerability. The hacker applies a state transition to the historical state of the system `stateX`. For example:
1. Alice sends money to Bob.
2. Bob sends money to Carrie. 

The hacker can generate a `State Transition Proof` using a ZK circuit. In the event that the applied transition results in an `incorrectState`, the zk proof would show the same. Ex: `Balance(Alice, t=0) + Balance(Bob, t=0) + Balance(Carrie, t=0) != Balance(Alice, t=1) + Balance(Bob, t=1) + Balance(Carrie, t=1)`. The dependencies to create such a formal proof are: 
1. The criteria and rules for what comprises an `incorrectState` would need to be provided by developers of the project/application and be a part of the `Hack Proof`. 
2. The public input `Hack Proof` should be encrypted by contract owner's public key such that only the contract owner is aware of where the bug is.

### Smart contract

We have 2 main smart contract functions
- `businessLogic` function for user to work with our pseudoERC20 Token. Inside `businessLogic` we have proof verification `State Transition Proof` which user will use for transfering money
- `proofOfHack` function which give you all bounty eth if you provide correct `Hack Proof`. This function will push red button and stop smart contract untill owner will recover it.

We have few Secondary Functions:
- `depositForBounty`
- `upgradeStateTransitionVerifier`, `upgradeHackVerifier` - upgradability function for providing new version of zk circiuts
- `recover` - restart smart contract after upgrade

## List of features

- [x] Main [contract](/contracts/contracts/ZkBugBounty.sol)
- [x] All [circuits](/circuits/src/main.rs)
- [x] Automaticaly generated vk for circuits (using [solidity plonk verifier](https://github.com/andreysobol/solidity_plonk_verifier))
- [ ] Change signature from hash based to schnorr 
- [ ] Add encryption for public input using contract owner public key
- [ ] Multiple transactions in bug proof
- [ ] Tooling for sending tx
- [ ] Proof agregation
- [ ] Some UI
- [ ] Real universal setup generated by AZTEC

## Tools and technologies

- [plonk](https://eprint.iacr.org/2019/953.pdf): prove system with universal trusted setup
- [belman_ce](https://github.com/matter-labs/bellman): fork of original belman with plonk
- [franklin-crypto](https://github.com/matter-labs/franklin-crypto): Gadget library for PLONK/Plookup
- [solidity plonk verifier](https://github.com/andreysobol/solidity_plonk_verifier) solidity plonk verifier with lookup tables
- [rescue poseidon](https://github.com/matter-labs/rescue-poseidon): Rescue and Poseidon argebraic hash circuit implementation 
- [hardhat](https://hardhat.org/): Eth contract toolkit

## How to use it

### Build circtuits

install rust and cargo

```
cd circuit
cargo build
```

### Generate VK

```
cd circuit
cargo run
```

### Generate Solidity Plonk Verifier

```
cd circuit/solidity_plonk_verifier/
cargo build --release
./target/release/solidity_plonk_verifier --verification-key /tmp/create_account_vk_keccak.key
cat ./hardhat/contracts/VerificationKey.sol | sed 's%import "hardhat/console.sol";% %g' > PATH_TO_SC/VerificationKey.sol
```

### Compile Smart Contracts

```
cd contracts
npx hardhat compile
```

### Deploy Smart Contracts

install nodejs and hardhat

```
cd contracts
npx hardhat run scripts/deploy.js
```

And you will get contract adresses

### Run user transaction

`TODO!:` make proper tooling for this

### Run proof of hack

`TODO!:` make proper tooling for this

## Meme

![Black and white hackers meme](/img/blackwhitememe.png)

